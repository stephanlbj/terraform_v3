# Infrastructure AWS avec Terraform

Ce projet provisionne une infrastructure complète sur AWS pour une application NestJS, avec trois environnements : `staging`, `preprod` et `prod`.

> ⚠️ **Important** : La branche par défaut pour tester est `staging`. Ne pas travailler sur `main` ou `preprod` directement.



## 🏗️ Composants provisionnés
- **VPC** avec subnets publics et privés
- **Security Groups** pour contrôler l’accès réseau
- **Route Tables**, NAT Gateway et Internet Gateway
- **ALB** et **Target Groups**
- **ECS Cluster** avec Fargate
- **ECR Repositories**
- **Services ECS** avec Task Definitions
- **S3 bucket** pour stocker l’état Terraform (`terraform.tfstate`)
- **DynamoDB table** pour **state locking**
- **IAM Roles & Policies** pour ECS et CI/CD

## 🔐 Sécurité
- Utilisation de **OIDC + SSM** pour gérer les secrets dynamiquement
- Permissions IAM minimales pour GitHub Actions et ECS

## ⚡ Utilisation
1. Cloner le projet :
```bash
git clone <URL_DU_REPO_TERRAFORM>
cd terraform



terraform init -backend-config="bucket=<S3_BUCKET_NAME>" -backend-config="key=<PATH>/terraform.tfstate" -backend-config="region=<AWS_REGION>"


Planifier et appliquer l’infrastructure :

terraform plan -var="environment=staging"
terraform apply -var="environment=staging"


Répéter pour preprod et prod en changeant la variable environment.

Initialiser Terraform avec S3 backend et DynamoDB lock :

terraform {
  backend "s3" {
  # bucket         = "my-terraform-states"  
   bucket         = "my-terraform-states-api-deploy-3" 
   key            = "infra/ecr/terraform.tfstate"   
   region         = "eu-north-1"                  
   # workspace_key_prefix = "env:"
   # use_lockfile   = true
   dynamodb_table = "terraform-locks-1"
   encrypt        = true

   
  }
}



🌐 Environnements

Chaque environnement dispose de ses propres ressources isolées pour staging, preprod et prod.


