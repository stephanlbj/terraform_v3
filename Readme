# Infrastructure AWS avec Terraform

Ce projet provisionne une infrastructure complÃ¨te sur AWS pour une application NestJS, avec trois environnements : `staging`, `preprod` et `prod`.

> âš ï¸ **Important** : La branche par dÃ©faut pour tester est `staging`. Ne pas travailler sur `main` ou `preprod` directement.



## ğŸ—ï¸ Composants provisionnÃ©s
- **VPC** avec subnets publics et privÃ©s
- **Security Groups** pour contrÃ´ler lâ€™accÃ¨s rÃ©seau
- **Route Tables**, NAT Gateway et Internet Gateway
- **ALB** et **Target Groups**
- **ECS Cluster** avec Fargate
- **ECR Repositories**
- **Services ECS** avec Task Definitions
- **S3 bucket** pour stocker lâ€™Ã©tat Terraform (`terraform.tfstate`)
- **DynamoDB table** pour **state locking**
- **IAM Roles & Policies** pour ECS et CI/CD

## ğŸ” SÃ©curitÃ©
- Utilisation de **OIDC + SSM** pour gÃ©rer les secrets dynamiquement
- Permissions IAM minimales pour GitHub Actions et ECS

## âš¡ Utilisation
1. Cloner le projet :
```bash
git clone <URL_DU_REPO_TERRAFORM>
cd terraform



terraform init -backend-config="bucket=<S3_BUCKET_NAME>" -backend-config="key=<PATH>/terraform.tfstate" -backend-config="region=<AWS_REGION>"


Planifier et appliquer lâ€™infrastructure :

terraform plan -var="environment=staging"
terraform apply -var="environment=staging"


RÃ©pÃ©ter pour preprod et prod en changeant la variable environment.

Initialiser Terraform avec S3 backend et DynamoDB lock :

terraform {
  backend "s3" {
  # bucket         = "my-terraform-states"  
   bucket         = "my-terraform-states-api-deploy-3" 
   key            = "infra/ecr/terraform.tfstate"   
   region         = "eu-north-1"                  
   # workspace_key_prefix = "env:"
   # use_lockfile   = true
   dynamodb_table = "terraform-locks-1"
   encrypt        = true

   
  }
}



ğŸŒ Environnements

Chaque environnement dispose de ses propres ressources isolÃ©es pour staging, preprod et prod.


